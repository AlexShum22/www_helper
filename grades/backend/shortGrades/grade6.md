## Грейд 6  

### Theory  

#### Минификация и обфускация кода  
Минимизация скрипта — это удаление из кода всех несущественных символов с целью уменьшения объема файла скрипта и  
ускорения его загрузки. В минимизированном коде удаляются все комментарии и незначащие пробелы, переносы строк, символы  
табуляции. В случае с Javascript, это уменьшает время загрузки страницы, т.к. размер файла уменьшается. Две самых  
популярных утилиты для минимизации javascript — JSMin и YUI Compressor.  

Обфускация является альтернативным способом сокращения исходного кода. Также, как минимизация, она удаляет  
пробельные символы и вырезает комментарии, но в дополнение она измененяет сам код. К примеру, во время  
обфускации имена функций и переменных заменяются на более короткие, что делает код более компактным, но менее  
читабельным. Обычно этот прием используется для усложнения реверс-инжиниринга программы. Но обфускация помогает  
также уменьшить код настолько, насколько это не получится сделать одной минимизацией. С выбором средства для  
обфускации javascript не все так ясно, но я думаю, что самая распространенная  
утилита для этого — Dojo Compressor (ShrinkSafe).  

#### Итераторы и генераторы  
PHP 5 предоставляет такой способ объявления объектов, который дает возможность пройти по списку элементов  
данного объекта, например, с помощью оператора foreach. По умолчанию, в этом обходе (итерации)  
будут участвовать все видимые свойства объекта.  

```php
$class = new MyClass();

foreach($class as $key => $value) {
    print "$key => $value\n";
}
```

Генераторы предоставляют лёгкий способ реализации простых итераторов без использования дополнительных ресурсов или  
сложностей, связанных с реализацией класса, реализующего интерфейс Iterator.  

Генератор позволяет вам писать код, использующий foreach для перебора набора данных без необходимости создания массива  
в памяти, что может привести к превышению лимита памяти, либо потребует довольно много времени для его создания.  
Вместо этого, вы можете написать функцию-генератор, которая, по сути, является обычной функцией, за исключением того,  
что вместо возврата единственного значения, генератор может возвращать (yield) столько раз, сколько необходимо для  
генерации значений, позволяющих перебрать исходный набор данных  

#### Аутентификация  
Аутентификация – это процедура проверки подлинности  
(пользователя проверяют с помощью пароля, письмо проверяют по электронной подписи и т.д.)  

#### Docker - обзор  

Докер это инструмент, который позволяет разработчикам, системными администраторам и другим специалистам деплоить их  
приложения в песочнице (которые называются контейнерами), для запуска на целевой операционной системе, например,  
Linux. Ключевое преимущество Докера в том, что он позволяет пользователям упаковать приложение со всеми его зависимостями  
в стандартизированный модуль для разработки. В отличие от виртуальных машин, контейнеры не создают такой  
дополнительной нагрузки, поэтому с ними можно использовать систему и ресурсы более эффективно.  

Контейнеры используют другой подход: они предоставляют схожий с виртуальными машинами уровень изоляции, но благодаря  
правильному задействованию низкоуровневых механизмов основной операционной системы делают это с в разы меньшей нагрузкой.  

### Language  

#### PHP Исключения  
Модель исключений (exceptions) в PHP похожа с используемыми в других языках программирования. Исключение можно  
сгенерировать (выбросить) при помощи оператора throw, и можно перехватить (поймать) оператором catch. Код  
генерирующий исключение, должен быть окружен блоком try, для того, чтобы можно было перехватить исключение.  
Каждый блок try должен иметь как минимум один соответствующий ему блок catch или finally.  

```php
<?php

try {
   //пробуем какой либо блок.
} catch (Exception $e) {
   //если есть ошибка, скрипт остановит свою деятельность и попадет сюда.
} finally {
    //этот блок выполниться в любом случае.
}

?>
```

#### ООП в PHP Свойства и методы  
```php
<?php

namespace app\example;

Class Example
{
    public int $appleCount; // публичное свойство               | this->water
    public static string $name; // публичное статичное свойство | self::$iron
    public const MONEY = 100; // константа                      | self::MONEY

    public function getAppleCount(): int
    {
        return $this->appleCount;
    }

    public static function sayMyName(): string
    {
        self::MONEY - 50;
        return self::$iron;
        
    }
}
```

#### Ключевое слово static  
```php
<?php
//Пример статического метода
class Foo {
    public static function aStaticMethod() {
        // ...
    }
}

Foo::aStaticMethod();
?>
```

Другой важной особенностью области видимости переменной является статическая переменная. Статическая переменная  
существует только в локальной области видимости функции, но не теряет своего значения, когда выполнение  
программы выходит из этой области видимости.  

```php
<?php
function test()
{
    static $a = 0;
    echo $a;
    $a++;
}
?>

test(); 
// 0
test(); 
// 1
```

Начиная с версии PHP 5.3.0 появилась особенность, называемая позднее статическое связывание, которая может быть  
использована для того, чтобы получить ссылку на вызываемый класс в контексте статического наследования.  
Если говорить более точно, позднее статическое связывание сохраняет имя класса указанного в последнем "неперенаправленном вызове".  

```php
<?php
class A {
    public static function who() {
        echo __CLASS__;
    }
    public static function test() {
        self::who();
    }
}

class B extends A {
    public static function who() {
        echo __CLASS__;
    }
}

B::test();
// A
?>
```

```php
<?php
class A {
    public static function who() {
        echo __CLASS__;
    }
    public static function test() {
        static::who(); // Здесь действует позднее статическое связывание
    }
}

class B extends A {
    public static function who() {
        echo __CLASS__;
    }
}

B::test();
// B
?>
```

### Framework  

#### Yii2 Структура приложения - входные скрипты  
Входные скрипты это первое звено в процессе начальной загрузки приложения. Приложение  
(веб приложение или консольное приложение) включает единый входной скрипт. Конечные пользователи делают  
запросы к входному скрипту, который создает объекты приложения и перенаправляет запрос к ним.  

```php
<?php
//Пример входного скрипта веб приложения.

defined('YII_DEBUG') or define('YII_DEBUG', true);
defined('YII_ENV') or define('YII_ENV', 'dev');

// регистрация загрузчика классов Composer
require __DIR__ . '/../vendor/autoload.php';

// подключение файла класса Yii
require __DIR__ . '/../vendor/yiisoft/yii2/Yii.php';

// загрузка конфигурации приложения
$config = require __DIR__ . '/../config/web.php';

// создание и конфигурация приложения, а также вызов метода для обработки входящего запроса
(new yii\web\Application($config))->run();
```

#### Yii2 Роутинг  
Имея готовые классы ресурсов и контроллеров, можно получить доступ к ресурсам, используя URL вроде  
http://localhost/user/create, подобно тому, как вы это делаете с обычными Web-приложениями.  

```php
//В config/web.php

'urlManager' => [
    'enablePrettyUrl' => true,
    'enableStrictParsing' => true,
    'showScriptName' => false,
    'rules' => [
        ['class' => 'yii\rest\UrlRule', 'controller' => 'user'],
        [
            //Контроллер                    //Url по которому будет доступен
            'center/services/comments/' => 'center/services/comment/',
        ]
    ],
];
```

#### Yii2 Загрузка классов  
Поиск и подключение файлов классов в Yii реализовано при помощи автозагрузки классов. Фреймворк предоставляет  
свой быстрый совместимый с PSR-4 автозагрузчик, который устанавливается в момент подключения Yii.php.  

- Каждый класс должен принадлежать пространству имён (то есть foo\bar\MyClass).
- Каждый класс должен находиться в отдельном файле, путь к которому определятся следующим правилом:
```php
// $className — это абсолютное имя класса без начального "\"
$classFile = Yii::getAlias('@' . str_replace('\\', '/', $className) . '.php');
```

Так как Yii использует Composer в качестве менеджера зависимостей, рекомендуется дополнительно установить его  
автозагрузчик. Если вы используете какие-либо сторонние библиотеки, в которых есть свои автозагрузчики, эти  
автозагрузчики также необходимо установить.  

При использовании дополнительных автозагрузчиков файл Yii.php должен быть подключен после их установки. Это позволит  
автозагрузчику Yii первым пробовать загрузить класс. К примеру, приведённый ниже код взят из входного скрипта  
шаблона приложения basic. Первая строка устанавливает автозагрузчик Composer, а вторая — автозагрузчик Yii:  
```php
require __DIR__ . '/../vendor/autoload.php';
require __DIR__ . '/../vendor/yiisoft/yii2/Yii.php';
```

#### Yii2 Миграции  
Yii поддерживает так называемую возможность миграции баз данных, которая позволяет отслеживать изменения в базах данных  
при помощи терминов миграции баз данных, которые являются системой контроля версий вместе с исходным кодом.  

Yii предоставляет набор инструментов для миграций из командной строки, которые позволяют:  
- создавать новые миграции;
- применять миграции;
- отменять миграции;
- применять миграции повторно;
- показывать историю и статус миграций;

### Testing  

#### Покрытие кода тестами  
Покры́тие ко́да — мера, используемая при тестировании программного обеспечения. Она показывает процент исходного кода  
программы, который был выполнен в процессе тестирования.  

#### Начальные данные  
Фикстуры - это по сути тестовые данные. Они нужны для unit-тестирования. Это могут быть как данные в базе,  
так и обычные файлы (обычно 2 варианта, до и после обработки так скажем). Каждый раз когда запускаются тесты,  
эти данные используются для установления начального состояния системы, что бы тесты всегда выполнялись предсказуемо.  

#### Определение результатов  
Проверка соответствия между реальным и ожидаемым поведением программы, осуществляемая на конечном наборе тестов,  
выбранном определенным образом. Процесс оценки системы или её компонентов с целью определения удовлетворяют ли  
результаты текущего этапа разработки условиям, сформированным в начале этого этапа.  

### Storage  

#### Нормальные формы 1НФ3НФ  
Нормализация - это удаление избыточности данных.  
Избыточность - это когда мы храним больше данных, чем это необходимо.  

Избыточность ведет к:  
- Увеличению занимаемого места на диске.
- Аномалиям включения, обновления, удаления.

##### Первая нормальная форма  
Основным правилом первой формы является необходимость неделимости значения в каждом поле (столбце) строки – атомарность значений.  

- Строки таблиц не должны зависеть друг от друга, т.е. первая запись не должна влиять на вторую и наоборот, вторая на  
третью и т.д. Размещение записей в таблице не имеет никакого значения.  
- Аналогичная ситуация со столбцами записей. Их порядок не должен влиять на понимание информации.  

Значения не атомарны  

|name           |hobby            |
|:------------- |:---------------:|
|Ivan           |bike, swimming   |
|Valya          |cook, reading    |

Значения атомарны  

|name           |hobby            |
|:------------- |:---------------:|
|Ivan           |bike             |
|Ivan           |swimming         |
|Valya          |cook             |
|Valya          |reading          |




Вторая нормальная форма  
Каждая строка должна быть уникальна, поэтому для нее определяется первичный ключ, состоящий из одного либо  
нескольких полей (составной ключ). Первичный ключ не может повторяться в пределах таблицы и служит идентификатором записи.  
Условием этой формы является отсутствие зависимости неключевых полей от части составного ключа.  

Находиться в первой НФ, но надо добавить primary key  

|name           |project          |project_client   |
|:------------- |:---------------:|:---------------:|
|Ivan           |App              |Jojo             |
|Ivan           |Store            |Boris            |
|Valya          |Green            |Boris            |
|Valya          |App              |Jojo             |

Добавим таблицу сотрудников и проектов.  

|id             |name           |
|:------------- |:------------- |
|1              |Ivan           |
|2              |Valya          |
|3              |Jojo           |
|4              |Boris          |

|id             |project        |
|:------------- |:------------- |
|1              |App            |
|2              |Store          |
|3              |Green          |

Зависимость сотрудников и проектов  

|project_id     |worker_id      |
|:------------- |:------------- |
|1              |1              |
|1              |3              |
|1              |2              |
|2              |1              |
|2              |1              |
|3              |2              |
|3              |4              |

Третья нормальная форма
3NF схожа по логике с 2NF, но с некоторым отличием. Если 2 форма ликвидирует зависимости неключевых полей от части  
ключа, то третья нормальная форма исключает зависимость неключевых полей от других неключевых полей.  

Номер телефона зависит от поставщика и от шины он никак не зависит.

|type_id        |type_name        |supplier         |supplier_phone   |
|:------------- |:---------------:|:---------------:|:---------------:|
|1              |wewe             |ИП Бар           |+79992222323     |
|2              |list             |ООО Год          |+78882222323     |
|3              |green            |ЗАО Друг         |+77772222323     |
|4              |nuun             |ИП Лук           |+76662222323     |

|type_id        |type_name        |supplier_id      |
|:------------- |:---------------:|:---------------:|
|1              |wewe             |1                |
|2              |list             |2                |
|3              |green            |3                |
|4              |nuun             |4                |

|id             |supplier         |supplier_phone   |
|:-------------:|:---------------:|:---------------:|
|1              |ИП Бар           |+79992222323     |
|2              |ООО Год          |+78882222323     |
|3              |ЗАО Друг         |+77772222323     |
|4              |ИП Лук           |+76662222323     |

### DB  

#### PostgreSQL Первичные ключи и индексы  
```
// Создать индекс
CREATE INDEX имя_индекса ON таблица (поле);

Для удаления индекса используется команда DROP INDEX. Добавлять и удалять индексы можно в любое время.
```
Создание индекса для большой таблицы может занимать много времени. По умолчанию Postgres Pro позволяет параллельно  
с созданием индекса выполнять чтение (операторы SELECT) таблицы, но операции записи (INSERT, UPDATE и DELETE)  
блокируются до окончания построения индекса.  

Типы индексов  
Postgres Pro поддерживает несколько типов индексов: B-дерево, хеш, GiST, SP-GiST, GIN и BRIN. Для разных типов  
индексов применяются разные алгоритмы, ориентированные на определённые типы запросов. По умолчанию команда  
CREATE INDEX создаёт индексы типа B-дерево, эффективные в большинстве случаев.  

Индекс можно создать не только по столбцу нижележащей таблицы, но и по функции или скалярному выражению с одним или  
несколькими столбцами таблицы. Это позволяет быстро находить данные в таблице по результатам вычислений.  

Частичный индекс — это индекс, который строится по подмножеству строк таблицы, определяемому условным выражением  
(оно называется предикатом частичного индекса). Такой индекс содержит записи только для строк, удовлетворяющих предикату.  

Один индекс может поддерживать только одно правило сортировки для индексируемого столбца. Поэтому при необходимости  
применять разные правила сортировки могут потребоваться несколько индексов.  

```
// Создание таблицы User с автоинкрементом id
CREATE TABLE user (
    id          SERIAL,
);
// serial    4 bytes autoincrementing integer       1 to 2147483647
// bigserial 8 bytes large autoincrementing integer 1 to 9223372036854775807
```

#### PostgreSQL Связывание  
Запрос, обращающийся к разным наборам строк одной или нескольких таблиц, называется соединением (JOIN).  
```
SELECT * FROM weather LEFT OUTER JOIN cities ON (weather.city = cities.name);

INNER JOIN => заберет только пересекающиеся значения двух таблиц
FULL OUTER JOIN => заберет все значения обоих таблиц c условием
LEFT OUTER JOIN => заберет все значения левой таблицы + пересекающиеся в правой

CROSS JOIN => все ко всем 4 x 4 = 16 rows
```

### Frontend
#### jQuery
jQuery это популярная библиотека JavaScript. Она была создана Джоном Резигом в 2006 году с целью облегчить  
разработчикам использование JavaScript на веб-сайтах.  
Особенность того, почему jQuery стала настолько успешной и популярной, это, вероятно, кроссплатформенные возможности.  
Она автоматически исправляет ошибки и работает таким же образом в наиболее часто используемых браузерах,  
таких как Chrome, Firefox, Safari, MS Edge, IE, Android и iOS.  

### DevOps  

#### psql  
psql — интерактивный терминал PostgreSQL  

### Git  

#### Cherry-pick
```git
$ git cherry-pick e43a6
Finished one cherry-pick.
[master]: created a0a41a9: "More friendly message when locking the index fails."
 3 files changed, 17 insertions(+), 3 deletions(-)
```

#### Rebase
```git
$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command
```

### Misc

#### Xdebug
Xdebug — это расширение для PHP (должно быть скомпилировано и установлено в процессе установки PHP) которое представляет  
разработчику следующий функционал для отладки:  

- Трассировки стека — вывод подробного пути, который привел приложение к полученной ошибке, включая параметры  
переданные в функции, в порядке позволяющем легко отследить ошибку
- Более приятный вывод var_dump, создающий подсветку кода и структурированный вид вместе с дампом суперглобальных  
переменных, по аналогии с VarDumper.
- Профайлер для поиска узких мест кода с возможностью визуализированного представления графиков производительности  
внешними инструментами. В результате получается график похожий на графики из Blackfire.
- Удаленный отладчик, который может быть использован при соединении с Xdebug для запуска и выполнения кода в  
IDE или браузере построчно через брейк-пойнты.
- “Покрытие кода” которое показывает какая часть кода была выполнена в процессе запроса. Это функция нужна по 
большей части для юнит-тестов и получения информации о том насколько хорошо ваш код покрыт тестами.

#### Менеджер зависимостей Composer
Composer — это менеджер зависимостей для PHP. Вы можете описать от каких библиотек зависит ваш проект и Composer  
установит нужные библиотеки за вас! Причём Composer — это не менеджер пакетов в классическом понимании. Да, он  
оперирует с сущностями, которые мы будем называть «пакетами» или библиотеками, но устанавливаются они внутрь  
каждого проекта отдельно, а не глобально (это одно из основных отличий от старого-доброго PEAR).  

пример composer.json  
```json
{
    "name": "coffee_learn_backend",
    "type": "project",
    "license": "BSD-3-Clause",
    "minimum-stability": "stable",
    "require": {
        "php": ">=7.3.6",
        "yiisoft/yii2": "~2.0.14",
        "yiithings/yii2-dotenv": "^1.0",
        "yiisoft/yii2-redis": "~2.0.0"
    },
    "require-dev": {
        "yiisoft/yii2-debug": "~2.1.0",
        "yiisoft/yii2-gii": "~2.1.0",
        "yiisoft/yii2-faker": "~2.0.0",
        "codeception/codeception": "^4.0",
        "codeception/verify": "~0.5.0 || ~1.1.0",
        "codeception/specify": "~0.4.6",
        "symfony/browser-kit": ">=2.7 <=4.2.4",
        "codeception/module-filesystem": "^1.0.0",
        "codeception/module-yii2": "^1.0.0",
        "codeception/module-asserts": "^1.0.0"
    },
    "config": {
        "process-timeout": 1800,
        "fxp-asset": {
            "enabled": false
        }
    },
    "scripts": {
        "post-install-cmd": [
            "yii\\composer\\Installer::postInstall"
        ],
        "post-create-project-cmd": [
            "yii\\composer\\Installer::postCreateProject",
            "yii\\composer\\Installer::postInstall"
        ]
    },
    "extra": {
        "yii\\composer\\Installer::postCreateProject": {
            "setPermission": [
                {
                    "runtime": "0777",
                    "web/assets": "0777",
                    "yii": "0755"
                }
            ]
        },
        "yii\\composer\\Installer::postInstall": {
            "generateCookieValidationKey": [
                "config/web.php"
            ]
        }
    },
    "autoload": {
        "psr-4": {
            "api\\" : "api/"
        }
    },
    "repositories": [
        {
            "type": "composer",
            "url": "https://asset-packagist.org"
        }
    ]
}
```
composer install -- проводит установку, в соответствии с инструкциями файла composer.json, при этом актуальные версии  
пакетов берутся из файла composer.lock (если он есть), если composer.lock, то он создаётся с указанием установленных  
версий (с точными их идентификаторами).  

composer update -- в соответствии с опциями файла composer.lock поищет в сети наиболее новые версии пакетов, обновит  
локальные копии пакетов и поправит composer.lock (а значит, при добавлении его в репу, ваши товарищи по команде тоже  
выгрузят уже более новые версии)  


#### Web-серверная архитектура: подробно
@inheritdoc  
