## Грейд 6  

### Theory  

#### Минификация и обфускация кода  
Минимизация скрипта — это удаление из кода всех несущественных символов с целью уменьшения объема файла скрипта и  
ускорения его загрузки. В минимизированном коде удаляются все комментарии и незначащие пробелы, переносы строк, символы  
табуляции. В случае с Javascript, это уменьшает время загрузки страницы, т.к. размер файла уменьшается. Две самых  
популярных утилиты для минимизации javascript — JSMin и YUI Compressor.  

Обфускация является альтернативным способом сокращения исходного кода. Также, как минимизация, она удаляет  
пробельные символы и вырезает комментарии, но в дополнение она измененяет сам код. К примеру, во время  
обфускации имена функций и переменных заменяются на более короткие, что делает код более компактным, но менее  
читабельным. Обычно этот прием используется для усложнения реверс-инжиниринга программы. Но обфускация помогает  
также уменьшить код настолько, насколько это не получится сделать одной минимизацией. С выбором средства для  
обфускации javascript не все так ясно, но я думаю, что самая распространенная  
утилита для этого — Dojo Compressor (ShrinkSafe).  

#### Итераторы и генераторы  
PHP 5 предоставляет такой способ объявления объектов, который дает возможность пройти по списку элементов  
данного объекта, например, с помощью оператора foreach. По умолчанию, в этом обходе (итерации)  
будут участвовать все видимые свойства объекта.  

```php
$class = new MyClass();

foreach($class as $key => $value) {
    print "$key => $value\n";
}
```

Генераторы предоставляют лёгкий способ реализации простых итераторов без использования дополнительных ресурсов или  
сложностей, связанных с реализацией класса, реализующего интерфейс Iterator.  

Генератор позволяет вам писать код, использующий foreach для перебора набора данных без необходимости создания массива  
в памяти, что может привести к превышению лимита памяти, либо потребует довольно много времени для его создания.  
Вместо этого, вы можете написать функцию-генератор, которая, по сути, является обычной функцией, за исключением того,  
что вместо возврата единственного значения, генератор может возвращать (yield) столько раз, сколько необходимо для  
генерации значений, позволяющих перебрать исходный набор данных  

```php
$even = [];
$numbers = [1,2,3,4,5,6,7,8,9,10];
$generator = getEvens($numbers);

function getEvens($numbers)
{
    foreach ($numbers as $number) {
        if ($number % 2 == 0) {
            yield $number;
        }
    }
}

foreach ($generator as $value) {
   print($value);
}

// 2, 4, 6, 8, 10
```

#### Аутентификация  
Аутентификация – это процедура проверки подлинности  
(пользователя проверяют с помощью пароля, письмо проверяют по электронной подписи и т.д.)  

#### Docker - обзор  
```yaml
version: "3.1"

services:
  php:
    build: php
    container_name: EXAMPLE_PHP
    restart: always
    volumes:
      - ${APPLICATION_DIR}:/var/www/backend
      - ./php/php.ini:/usr/local/etc/php/php.ini
    environment:
      PHP_IDE_CONFIG: "serverName=Docker"
    depends_on:
      - EXAMPLE_NGINX
    networks:
      - example

  nginx:
    build: nginx
    container_name: EXAMPLE_NGINX
    restart: always
    volumes:
      - ./nginx/config/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/config/default.conf:/etc/nginx/conf.d/default.conf
      - ${APPLICATION_DIR}:/var/www/backend
    ports:
      - 127.0.0.1:${NGINX_PORT}
    networks:
      - example

networks:
   example:
    driver: bridge
```
### Language  

#### PHP Исключения  
Модель исключений (exceptions) в PHP похожа с используемыми в других языках программирования. Исключение можно  
сгенерировать (выбросить) при помощи оператора throw, и можно перехватить (поймать) оператором catch. Код  
генерирующий исключение, должен быть окружен блоком try, для того, чтобы можно было перехватить исключение.  
Каждый блок try должен иметь как минимум один соответствующий ему блок catch или finally.  

```php
<?php

try {
   //пробуем какой либо блок.
} catch (Exception $e) {
   //если есть ошибка, скрипт остановит свою деятельность и попадет сюда.
} finally {
    //этот блок выполниться в любом случае.
}

?>
```

#### ООП в PHP Свойства и методы  
```php
<?php

namespace app\example;

Class Example
{
    public int $appleCount; // публичное свойство               | this->water
    public static string $name; // публичное статичное свойство | self::$iron
    public const MONEY = 100; // константа                      | self::MONEY

    public function getAppleCount(): int
    {
        return $this->appleCount;
    }

    public static function sayMyName(): string
    {
        self::MONEY - 50;
        return self::$iron;
        
    }
}
```

#### Ключевое слово static  
```php
<?php
//Пример статического метода
class Foo {
    public static function aStaticMethod() {
        // ...
    }
}

Foo::aStaticMethod();
?>
```

Другой важной особенностью области видимости переменной является статическая переменная. Статическая переменная  
существует только в локальной области видимости функции, но не теряет своего значения, когда выполнение  
программы выходит из этой области видимости.  

```php
<?php
function test()
{
    static $a = 0;
    echo $a;
    $a++;
}
?>

test(); 
// 0
test(); 
// 1
```

Начиная с версии PHP 5.3.0 появилась особенность, называемая позднее статическое связывание, которая может быть  
использована для того, чтобы получить ссылку на вызываемый класс в контексте статического наследования.  
Если говорить более точно, позднее статическое связывание сохраняет имя класса указанного в последнем "неперенаправленном вызове".  

```php
<?php
class A {
    public static function who() {
        echo __CLASS__;
    }
    public static function test() {
        self::who();
    }
}

class B extends A {
    public static function who() {
        echo __CLASS__;
    }
}

B::test();
// A
?>
```

```php
<?php
class A {
    public static function who() {
        echo __CLASS__;
    }
    public static function test() {
        static::who(); // Здесь действует позднее статическое связывание
    }
}

class B extends A {
    public static function who() {
        echo __CLASS__;
    }
}

B::test();
// B
?>
```

### Framework  

#### Yii2 Структура приложения - входные скрипты  
Входные скрипты это первое звено в процессе начальной загрузки приложения. Приложение  
(веб приложение или консольное приложение) включает единый входной скрипт. Конечные пользователи делают  
запросы к входному скрипту, который создает объекты приложения и перенаправляет запрос к ним.  

```php
<?php
//Пример входного скрипта веб приложения.

defined('YII_DEBUG') or define('YII_DEBUG', true);
defined('YII_ENV') or define('YII_ENV', 'dev');

// регистрация загрузчика классов Composer
require __DIR__ . '/../vendor/autoload.php';

// подключение файла класса Yii
require __DIR__ . '/../vendor/yiisoft/yii2/Yii.php';

// загрузка конфигурации приложения
$config = require __DIR__ . '/../config/web.php';

// создание и конфигурация приложения, а также вызов метода для обработки входящего запроса
(new yii\web\Application($config))->run();
```

#### Yii2 Роутинг  
Имея готовые классы ресурсов и контроллеров, можно получить доступ к ресурсам, используя URL вроде  
http://localhost/user/create, подобно тому, как вы это делаете с обычными Web-приложениями.  

```php
//В config/web.php

'urlManager' => [
    'enablePrettyUrl' => true,
    'enableStrictParsing' => true,
    'showScriptName' => false,
    'rules' => [
        ['class' => 'yii\rest\UrlRule', 'controller' => 'user'],
        [
            //Контроллер                    //Url по которому будет доступен
            'center/services/comments/' => 'center/services/comment/',
        ]
    ],
];
```

#### Yii2 Загрузка классов  
Поиск и подключение файлов классов в Yii реализовано при помощи автозагрузки классов. Фреймворк предоставляет  
свой быстрый совместимый с PSR-4 автозагрузчик, который устанавливается в момент подключения Yii.php.  

- Каждый класс должен принадлежать пространству имён (то есть foo\bar\MyClass).
- Каждый класс должен находиться в отдельном файле, путь к которому определятся следующим правилом:
```php
// $className — это абсолютное имя класса без начального "\"
$classFile = Yii::getAlias('@' . str_replace('\\', '/', $className) . '.php');
```

Так как Yii использует Composer в качестве менеджера зависимостей, рекомендуется дополнительно установить его  
автозагрузчик. Если вы используете какие-либо сторонние библиотеки, в которых есть свои автозагрузчики, эти  
автозагрузчики также необходимо установить.  

При использовании дополнительных автозагрузчиков файл Yii.php должен быть подключен после их установки. Это позволит  
автозагрузчику Yii первым пробовать загрузить класс. К примеру, приведённый ниже код взят из входного скрипта  
шаблона приложения basic. Первая строка устанавливает автозагрузчик Composer, а вторая — автозагрузчик Yii:  
```php
require __DIR__ . '/../vendor/autoload.php';
require __DIR__ . '/../vendor/yiisoft/yii2/Yii.php';
```

#### Yii2 Миграции  
Yii поддерживает так называемую возможность миграции баз данных, которая позволяет отслеживать изменения в базах данных  
при помощи терминов миграции баз данных, которые являются системой контроля версий вместе с исходным кодом.  

Yii предоставляет набор инструментов для миграций из командной строки, которые позволяют:  
- создавать новые миграции;
- применять миграции;
- отменять миграции;
- применять миграции повторно;
- показывать историю и статус миграций;

### Testing  

#### Покрытие кода тестами  
Покры́тие ко́да — мера, используемая при тестировании программного обеспечения. Она показывает процент исходного кода  
программы, который был выполнен в процессе тестирования.  

#### Начальные данные  
Фикстуры - это по сути тестовые данные. Они нужны для unit-тестирования. Это могут быть как данные в базе,  
так и обычные файлы (обычно 2 варианта, до и после обработки так скажем). Каждый раз когда запускаются тесты,  
эти данные используются для установления начального состояния системы, что бы тесты всегда выполнялись предсказуемо.  

#### Определение результатов  
@inheritdoc  

### Storage  

#### Нормальные формы 1НФ3НФ  
Первая нормальная форма  
Основным правилом первой формы является необходимость неделимости значения в каждом поле (столбце) строки – атомарность значений.  

- Строки таблиц не должны зависеть друг от друга, т.е. первая запись не должна влиять на вторую и наоборот, вторая на  
третью и т.д. Размещение записей в таблице не имеет никакого значения.  
- Аналогичная ситуация со столбцами записей. Их порядок не должен влиять на понимание информации.  
- Каждая строка должна быть уникальна, поэтому для нее определяется первичный ключ, состоящий из одного либо  
нескольких полей (составной ключ). Первичный ключ не может повторяться в пределах таблицы и служит идентификатором записи.  

Вторая нормальная форма  
Условием этой формы является отсутствие зависимости неключевых полей от части составного ключа.  

Третья нормальная форма
3NF схожа по логике с 2NF, но с некоторым отличием. Если 2 форма ликвидирует зависимости неключевых полей от части  
ключа, то третья нормальная форма исключает зависимость неключевых полей от других неключевых полей.  

### DB  

#### PostgreSQL Первичные ключи и индексы  
#### PostgreSQL Связывание  
@inheritdoc  

### Frontend
#### jQuery
@inheritdoc  

### DevOps  

#### psql  
psql — интерактивный терминал PostgreSQL  

### Git  

#### Cherry-pick
```git
$ git cherry-pick e43a6
Finished one cherry-pick.
[master]: created a0a41a9: "More friendly message when locking the index fails."
 3 files changed, 17 insertions(+), 3 deletions(-)
```

#### Rebase
```git
$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command
```

### Misc

#### Xdebug
Xdebug — это расширение для PHP (должно быть скомпилировано и установлено в процессе установки PHP) которое представляет  
разработчику следующий функционал для отладки:  

- Трассировки стека — вывод подробного пути, который привел приложение к полученной ошибке, включая параметры  
переданные в функции, в порядке позволяющем легко отследить ошибку
- Более приятный вывод var_dump, создающий подсветку кода и структурированный вид вместе с дампом суперглобальных  
переменных, по аналогии с VarDumper.
- Профайлер для поиска узких мест кода с возможностью визуализированного представления графиков производительности  
внешними инструментами. В результате получается график похожий на графики из Blackfire.
- Удаленный отладчик, который может быть использован при соединении с Xdebug для запуска и выполнения кода в  
IDE или браузере построчно через брейк-пойнты.
- “Покрытие кода” которое показывает какая часть кода была выполнена в процессе запроса. Это функция нужна по 
большей части для юнит-тестов и получения информации о том насколько хорошо ваш код покрыт тестами.

#### Менеджер зависимостей Composer
Composer — это менеджер зависимостей для PHP. Вы можете описать от каких библиотек зависит ваш проект и Composer  
установит нужные библиотеки за вас! Причём Composer — это не менеджер пакетов в классическом понимании. Да, он  
оперирует с сущностями, которые мы будем называть «пакетами» или библиотеками, но устанавливаются они внутрь  
каждого проекта отдельно, а не глобально (это одно из основных отличий от старого-доброго PEAR).  

пример composer.json  
```json
{
    "name": "coffee_learn_backend",
    "type": "project",
    "license": "BSD-3-Clause",
    "minimum-stability": "stable",
    "require": {
        "php": ">=7.3.6",
        "yiisoft/yii2": "~2.0.14",
        "yiithings/yii2-dotenv": "^1.0",
        "yiisoft/yii2-redis": "~2.0.0"
    },
    "require-dev": {
        "yiisoft/yii2-debug": "~2.1.0",
        "yiisoft/yii2-gii": "~2.1.0",
        "yiisoft/yii2-faker": "~2.0.0",
        "codeception/codeception": "^4.0",
        "codeception/verify": "~0.5.0 || ~1.1.0",
        "codeception/specify": "~0.4.6",
        "symfony/browser-kit": ">=2.7 <=4.2.4",
        "codeception/module-filesystem": "^1.0.0",
        "codeception/module-yii2": "^1.0.0",
        "codeception/module-asserts": "^1.0.0"
    },
    "config": {
        "process-timeout": 1800,
        "fxp-asset": {
            "enabled": false
        }
    },
    "scripts": {
        "post-install-cmd": [
            "yii\\composer\\Installer::postInstall"
        ],
        "post-create-project-cmd": [
            "yii\\composer\\Installer::postCreateProject",
            "yii\\composer\\Installer::postInstall"
        ]
    },
    "extra": {
        "yii\\composer\\Installer::postCreateProject": {
            "setPermission": [
                {
                    "runtime": "0777",
                    "web/assets": "0777",
                    "yii": "0755"
                }
            ]
        },
        "yii\\composer\\Installer::postInstall": {
            "generateCookieValidationKey": [
                "config/web.php"
            ]
        }
    },
    "autoload": {
        "psr-4": {
            "api\\" : "api/"
        }
    },
    "repositories": [
        {
            "type": "composer",
            "url": "https://asset-packagist.org"
        }
    ]
}
```
composer install -- проводит установку, в соответствии с инструкциями файла composer.json, при этом актуальные версии  
пакетов берутся из файла composer.lock (если он есть), если composer.lock, то он создаётся с указанием установленных  
версий (с точными их идентификаторами).  

composer update -- в соответствии с опциями файла composer.lock поищет в сети наиболее новые версии пакетов, обновит  
локальные копии пакетов и поправит composer.lock (а значит, при добавлении его в репу, ваши товарищи по команде тоже  
выгрузят уже более новые версии)  


#### Web-серверная архитектура: подробно
@inheritdoc  
